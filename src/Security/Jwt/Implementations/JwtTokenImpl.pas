{*!
 * Fano Web Framework (https://fanoframework.github.io)
 *
 * @link      https://github.com/fanoframework/fano
 * @copyright Copyright (c) 2018 - 2020 Zamrony P. Juhara
 * @license   https://github.com/fanoframework/fano/blob/master/LICENSE (MIT)
 *}

unit JwtTokenImpl;

interface

{$MODE OBJFPC}
{$H+}

uses

    TokenVerifierIntf,
    JwtAlgIntf,
    InjectableObjectImpl;

type

    //supported JWT algorithm
    TAlg = record
        //algorithm name
        alg : shortstring;

        //instance responsible to verify signature
        inst : IJwtAlg;
    end;
    TAlgArray = array of TAlg;

    (*!------------------------------------------------
     * class having capability to verify JWT token validity
     *
     * @author Zamrony P. Juhara <zamronypj@yahoo.com>
     *-------------------------------------------------*)
    TJwtToken = class (TInjectableObject, ITokenVerifier)
    private
        fAlgorithms : TAlgArray;
        fIssuer : string;
        fSecretKey : string;
        function findAlgoIndexByName(const alg : shortstring) : integer;
        procedure cleanUpAlgorithms();
    public
        (*!------------------------------------------------
         * constructor
         *-------------------------------------------------
         * @param issuer JWT issuer string
         * @param secretKey secret key used to verify signature
         * @param algos array of supported algorithms
         *-------------------------------------------------*)
        constructor create(
            const issuer : string;
            const secretKey : string;
            const algos: array of TAlg
        );

        (*!------------------------------------------------
         * destructor
         *-------------------------------------------------*)
        destructor destroy(); override;

        (*!------------------------------------------------
         * verify token
         *-------------------------------------------------
         * @param token token to verify
         * @return boolean true if token is verified and
         *        not expired and issuer match
         *-------------------------------------------------*)
        function verify(const token : string) : boolean;

    end;

implementation

uses

    sysutils,
    dateutils,
    fpjson,
    fpjwt;

const
    ALG_NOTFOUND = -1;

    (*!------------------------------------------------
     * constructor
     *-------------------------------------------------
     * @param issuer JWT issuer string
     * @param secretKey secret key used to verify signature
     * @param algos array of supported algorithms
     *-------------------------------------------------*)
    constructor TJwtToken.create(
        const issuer : string;
        const secretKey : string;
        const algos: array of TAlg
    );
    var i : integer;
    begin
        fIssuer := issuer;
        fSecretKey := secretKey;
        setLength(fAlgorithms, high(algos) - low(algos) + 1);
        for i := low(algos) to high(algos) do
        begin
            fAlgorithms[i] := algos[i];
        end;
    end;

    (*!------------------------------------------------
     * destructor
     *-------------------------------------------------*)
    destructor TJwtToken.destroy();
    begin
        cleanUpAlgorithms();
        fAlgorithms := nil;
        inherited destroy();
    end;

    procedure TJwtToken.cleanUpAlgorithms();
    var i : integer;
    begin
        for i := length(fAlgorithms)-1 downto 0 do
        begin
            fAlgorithms[i].inst := nil;
        end;
    end;

    function TJwtToken.findAlgoIndexByName(const alg : shortstring) : integer;
    var i, len : integer;
    begin
        //number of algorithms is very small, sequential search is good enough
        result := ALG_NOTFOUND;
        len := length(fAlgorithms);
        for i := 0 to len-1 do
        begin
            if (alg = fAlgorithms[i].alg) then
            begin
                //algorithm found
                result := i;
                break;
            end;
        end;
    end;

    (*!------------------------------------------------
     * verify token
     *-------------------------------------------------
     * @param token token to verify
     * @return boolean true if token is verified and
     *         not expired and issuer match
     *-------------------------------------------------*)
    function TJwtToken.verify(const token : string) : boolean;
    var jwt : TJwt;
        algIndex : integer;
    begin
        jwt := TJwt.create();
        try
            try
                //this may raise EJSON when token is not well-formed JWT
                jwt.asEncodedString := token;

                //if we get here, token is well-formed JWT
                algIndex := findAlgoIndexByName(jwt.JOSE.alg);

                //test if signing algorithm is known, if not, then token is
                //definitely not generated by us or token has been tampered.
                result := (algIndex <> ALG_NOTFOUND) and

                    //if algorithm is known, check signature
                    fAlgorithm[algIndex].inst.verify(
                        jwt.JOSE.AsEncodedString + '.' + jwt.Claims.AsEncodedString,
                        jwt.Signature,
                        fSecretKey
                    ) and

                    //if signature valid, check if expired
                    (jwt.Claims.exp > DateTimeToUnix(Now)) and

                    //if not expired, check if issuer match
                    (jwt.Claims.iss = fIssuer);
            except
                on e : EJSON do
                begin
                    //if we get here, token is not valid JWT
                    result := false;
                end;
            end;
        finally
            jwt.free();
        end;
    end;

end.
